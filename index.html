<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Best Cipher Machine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #000000;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            line-height: 1.6;
        }

        .machine-container {
            background: #ffffff;
            border: 2px solid #000000;
            border-radius: 0;
            padding: 40px;
            max-width: 800px;
            width: 100%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            border-bottom: 2px solid #000000;
            padding-bottom: 20px;
        }

        .header h1 {
            font-size: 2.5em;
            color: #000000;
            margin-bottom: 10px;
            font-weight: 700;
            letter-spacing: -1px;
        }

        .header p {
            color: #666666;
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .language-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .lang-btn {
            padding: 8px 16px;
            border: 1px solid #000000;
            background: #ffffff;
            color: #000000;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .lang-btn:hover {
            background: #000000;
            color: #ffffff;
        }

        .lang-btn.active {
            background: #000000;
            color: #ffffff;
        }

        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .mode-btn {
            padding: 15px 30px;
            border: 2px solid #000000;
            background: #ffffff;
            color: #000000;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mode-btn:hover {
            background: #000000;
            color: #ffffff;
        }

        .mode-btn.active {
            background: #000000;
            color: #ffffff;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #000000;
            font-size: 1.1em;
        }

        .input-group input, .input-group textarea {
            width: 100%;
            padding: 15px;
            border: 2px solid #000000;
            border-radius: 0;
            font-size: 1em;
            transition: all 0.2s ease;
            background: #ffffff;
            color: #000000;
        }

        .input-group input:focus, .input-group textarea:focus {
            outline: none;
            border-color: #666666;
            background: #f9f9f9;
        }

        .input-group textarea {
            resize: vertical;
            min-height: 120px;
            font-family: 'Courier New', monospace;
        }

        .rotor-key-input {
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
            text-align: center;
        }

        .process-btn {
            width: 100%;
            padding: 20px;
            border: 2px solid #000000;
            border-radius: 0;
            font-size: 1.3em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 20px;
            background: #ffffff;
            color: #000000;
        }

        .process-btn:hover {
            background: #000000;
            color: #ffffff;
        }

        .process-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #f0f0f0;
            color: #999999;
        }

        .result-section {
            margin-top: 30px;
            padding: 20px;
            background: #f9f9f9;
            border: 2px solid #000000;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .result-content {
            text-align: center;
            width: 100%;
        }

        .result-text {
            font-family: 'Courier New', monospace;
            font-size: 1.2em;
            line-height: 1.6;
            color: #000000;
            word-break: break-all;
            padding: 10px;
            background: #ffffff;
            border: 1px solid #000000;
            margin: 10px 0;
        }

        .result-label {
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 1.1em;
            color: #000000;
        }

        .copy-btn {
            margin-top: 10px;
            padding: 10px 20px;
            background: #ffffff;
            color: #000000;
            border: 1px solid #000000;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .copy-btn:hover {
            background: #000000;
            color: #ffffff;
        }

        .placeholder {
            color: #999999;
            font-style: italic;
        }

        .error {
            color: #cc0000;
            font-weight: 600;
            margin-top: 10px;
        }

        .rotor-visualization {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .rotor {
            width: 50px;
            height: 50px;
            border: 2px solid #000000;
            background: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000000;
            font-weight: bold;
            font-size: 1.2em;
            animation: rotate 2s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .info-panel {
            background: #f9f9f9;
            border: 2px solid #000000;
            padding: 15px;
            margin: 20px 0;
        }

        .info-panel h3 {
            color: #000000;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .info-panel p {
            color: #333333;
            line-height: 1.5;
        }

        .generate-btn {
            margin-top: 10px;
            padding: 8px 16px;
            background: #ffffff;
            color: #000000;
            border: 1px solid #000000;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .generate-btn:hover {
            background: #000000;
            color: #ffffff;
        }

        @media (max-width: 600px) {
            .machine-container {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .mode-selector {
                flex-direction: column;
                align-items: center;
            }
            
            .mode-btn {
                width: 100%;
                max-width: 200px;
            }

            .language-selector {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="machine-container">
        <div class="header">
            <h1 id="main-title">The Best Cipher Machine</h1>
            <p id="main-description">Seed-driven encryption inspired by historical machines like Enigma, featuring dynamic rotor shifts and hash-based randomization.</p>
            
            <div class="language-selector">
                <button class="lang-btn active" onclick="changeLanguage('en')">English</button>
                <button class="lang-btn" onclick="changeLanguage('ko')">한국어</button>
                <button class="lang-btn" onclick="changeLanguage('zh')">中文</button>
                <button class="lang-btn" onclick="changeLanguage('sv')">Svenska</button>
            </div>
        </div>

        <div class="info-panel">
            <h3 id="how-it-works">How it works:</h3>
            <p id="how-it-works-desc">This cipher uses a 32-character rotor key (only 'a' to 'd') combined with a random seed to create dynamic encryption. Each character is shifted by an offset calculated from both the rotor position and a hash-based pseudo-random value derived from the seed.</p>
        </div>

        <div class="mode-selector">
            <button class="mode-btn encrypt active" onclick="setMode('encrypt')">
                <span id="encrypt-text">Encrypt</span>
            </button>
            <button class="mode-btn decrypt" onclick="setMode('decrypt')">
                <span id="decrypt-text">Decrypt</span>
            </button>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label for="textInput" id="textLabel">Enter plaintext to encrypt:</label>
                <textarea id="textInput" placeholder="Type your message here..."></textarea>
            </div>

            <div class="input-group">
                <label for="rotorKey" id="rotor-key-label">Rotor Key (32 characters, only 'a' to 'd'):</label>
                <input type="text" id="rotorKey" class="rotor-key-input" maxlength="32" placeholder="abcdabcdabcdabcdabcdabcdabcdabcd">
                <button type="button" class="generate-btn" onclick="generateRotorKey()">
                    <span id="generate-text">Generate Random Key</span>
                </button>
            </div>

            <div class="input-group">
                <label for="seed" id="seed-label">Random Seed (any string):</label>
                <input type="text" id="seed" placeholder="Enter your secret seed">
            </div>

            <div class="rotor-visualization" id="rotorViz"></div>

            <button class="process-btn" id="processBtn" onclick="processText()">
                <span id="process-text">Encrypt Message</span>
            </button>
            
            <div id="error" class="error"></div>
        </div>

        <div class="result-section">
            <div class="result-content">
                <div id="resultLabel" class="result-label placeholder">Your result will appear here</div>
                <div id="resultText" class="result-text" style="display: none;"></div>
                <button class="copy-btn" id="copyBtn" style="display: none;" onclick="copyResult()">
                    <span id="copy-text">Copy Result</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // Language translations
        const translations = {
            en: {
                title: "The Best Cipher Machine",
                description: "Seed-driven encryption inspired by historical machines like Enigma, featuring dynamic rotor shifts and hash-based randomization.",
                howItWorks: "How it works:",
                howItWorksDesc: "This cipher uses a 32-character rotor key (only 'a' to 'd') combined with a random seed to create dynamic encryption. Each character is shifted by an offset calculated from both the rotor position and a hash-based pseudo-random value derived from the seed.",
                encrypt: "Encrypt",
                decrypt: "Decrypt",
                encryptLabel: "Enter plaintext to encrypt:",
                decryptLabel: "Enter ciphertext to decrypt:",
                rotorKeyLabel: "Rotor Key (32 characters, only 'a' to 'd'):",
                seedLabel: "Random Seed (any string):",
                generateKey: "Generate Random Key",
                encryptBtn: "Encrypt Message",
                decryptBtn: "Decrypt Message",
                processing: "Processing...",
                resultPlaceholder: "Your result will appear here",
                encryptedResult: "Encrypted Result:",
                decryptedResult: "Decrypted Result:",
                copyResult: "Copy Result",
                copied: "Copied!",
                encryptPlaceholder: "Type your message here...",
                decryptPlaceholder: "Paste encrypted text here...",
                seedPlaceholder: "Enter your secret seed",
                errorEmptyText: "Please enter some text to process.",
                errorRotorLength: "Rotor key must be exactly 32 characters long.",
                errorRotorChars: "Rotor key must contain only characters a, b, c, d.",
                errorEmptySeed: "Please enter a random seed.",
                errorProcessing: "An error occurred during processing."
            },
            ko: {
                title: "최고의 암호 기계",
                description: "에니그마와 같은 역사적 기계에서 영감을 받은 시드 기반 암호화, 동적 로터 이동과 해시 기반 무작위화를 특징으로 합니다.",
                howItWorks: "작동 방식:",
                howItWorksDesc: "이 암호는 32자 로터 키('a'에서 'd'만 사용)와 랜덤 시드를 결합하여 동적 암호화를 생성합니다. 각 문자는 로터 위치와 시드에서 파생된 해시 기반 의사 난수 값으로 계산된 오프셋만큼 이동됩니다.",
                encrypt: "암호화",
                decrypt: "복호화",
                encryptLabel: "암호화할 평문을 입력하세요:",
                decryptLabel: "복호화할 암호문을 입력하세요:",
                rotorKeyLabel: "로터 키 (32자, 'a'부터 'd'까지만):",
                seedLabel: "랜덤 시드 (임의의 문자열):",
                generateKey: "랜덤 키 생성",
                encryptBtn: "메시지 암호화",
                decryptBtn: "메시지 복호화",
                processing: "처리 중...",
                resultPlaceholder: "결과가 여기에 표시됩니다",
                encryptedResult: "암호화 결과:",
                decryptedResult: "복호화 결과:",
                copyResult: "결과 복사",
                copied: "복사됨!",
                encryptPlaceholder: "메시지를 입력하세요...",
                decryptPlaceholder: "암호화된 텍스트를 붙여넣으세요...",
                seedPlaceholder: "비밀 시드를 입력하세요",
                errorEmptyText: "처리할 텍스트를 입력해주세요.",
                errorRotorLength: "로터 키는 정확히 32자여야 합니다.",
                errorRotorChars: "로터 키는 a, b, c, d 문자만 포함해야 합니다.",
                errorEmptySeed: "랜덤 시드를 입력해주세요.",
                errorProcessing: "처리 중 오류가 발생했습니다."
            },
            zh: {
                title: "最佳密码机",
                description: "受恩尼格玛等历史机器启发的种子驱动加密，具有动态转子移位和基于哈希的随机化功能。",
                howItWorks: "工作原理：",
                howItWorksDesc: "该密码使用32字符转子密钥（仅'a'到'd'）与随机种子相结合来创建动态加密。每个字符都会根据转子位置和从种子派生的基于哈希的伪随机值计算的偏移量进行移位。",
                encrypt: "加密",
                decrypt: "解密",
                encryptLabel: "输入要加密的明文：",
                decryptLabel: "输入要解密的密文：",
                rotorKeyLabel: "转子密钥（32字符，仅'a'到'd'）：",
                seedLabel: "随机种子（任意字符串）：",
                generateKey: "生成随机密钥",
                encryptBtn: "加密消息",
                decryptBtn: "解密消息",
                processing: "处理中...",
                resultPlaceholder: "结果将显示在这里",
                encryptedResult: "加密结果：",
                decryptedResult: "解密结果：",
                copyResult: "复制结果",
                copied: "已复制！",
                encryptPlaceholder: "在此输入您的消息...",
                decryptPlaceholder: "在此粘贴加密文本...",
                seedPlaceholder: "输入您的秘密种子",
                errorEmptyText: "请输入一些要处理的文本。",
                errorRotorLength: "转子密钥必须正好是32个字符长。",
                errorRotorChars: "转子密钥必须只包含字符a、b、c、d。",
                errorEmptySeed: "请输入随机种子。",
                errorProcessing: "处理过程中发生错误。"
            },
            sv: {
                title: "Den Bästa Chiffermaskin",
                description: "Frö-driven kryptering inspirerad av historiska maskiner som Enigma, med dynamiska rotorförskjutningar och hash-baserad randomisering.",
                howItWorks: "Så fungerar det:",
                howItWorksDesc: "Denna chiffer använder en 32-tecken rotornyckel (endast 'a' till 'd') kombinerad med ett slumpmässigt frö för att skapa dynamisk kryptering. Varje tecken förskjuts med en offset beräknad från både rotorpositionen och ett hash-baserat pseudoslumpvärde härledd från fröet.",
                encrypt: "Kryptera",
                decrypt: "Dekryptera",
                encryptLabel: "Ange klartext att kryptera:",
                decryptLabel: "Ange chiffertext att dekryptera:",
                rotorKeyLabel: "Rotornyckel (32 tecken, endast 'a' till 'd'):",
                seedLabel: "Slumpmässigt frö (valfri sträng):",
                generateKey: "Generera Slumpmässig Nyckel",
                encryptBtn: "Kryptera Meddelande",
                decryptBtn: "Dekryptera Meddelande",
                processing: "Bearbetar...",
                resultPlaceholder: "Ditt resultat kommer att visas här",
                encryptedResult: "Krypterat Resultat:",
                decryptedResult: "Dekrypterat Resultat:",
                copyResult: "Kopiera Resultat",
                copied: "Kopierat!",
                encryptPlaceholder: "Skriv ditt meddelande här...",
                decryptPlaceholder: "Klistra in krypterad text här...",
                seedPlaceholder: "Ange ditt hemliga frö",
                errorEmptyText: "Vänligen ange lite text att bearbeta.",
                errorRotorLength: "Rotornyckeln måste vara exakt 32 tecken lång.",
                errorRotorChars: "Rotornyckeln får endast innehålla tecknen a, b, c, d.",
                errorEmptySeed: "Vänligen ange ett slumpmässigt frö.",
                errorProcessing: "Ett fel uppstod under bearbetningen."
            }
        };

        // Cipher implementation
        const LETTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .,!?()';
        const ROTOR_CHARS = 'abcd';
        
        let currentMode = 'encrypt';
        let currentLanguage = 'en';

        function rotorCharOffset(ch) {
            return ROTOR_CHARS.indexOf(ch);
        }

        function shiftChar(ch, offset) {
            if (!LETTERS.includes(ch)) {
                return ch;
            }
            const idx = LETTERS.indexOf(ch);
            return LETTERS[(idx + offset) % LETTERS.length];
        }

        async function sha256(message) {
            const msgBuffer = new TextEncoder().encode(message);
            const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hashHex;
        }

        async function dynamicOffset(i, auxKey, seed) {
            const baseOffset = rotorCharOffset(auxKey[i % auxKey.length]);
            const seedInput = `${seed}:${i}`;
            const hashDigest = await sha256(seedInput);
            const prngValue = parseInt(hashDigest.slice(0, 2), 16) % ROTOR_CHARS.length;
            return (baseOffset + prngValue) % LETTERS.length;
        }

        async function encrypt(text, auxKey, seed) {
            let encrypted = '';
            for (let i = 0; i < text.length; i++) {
                const offset = await dynamicOffset(i, auxKey, seed);
                encrypted += shiftChar(text[i], offset);
            }
            return encrypted;
        }

        async function decrypt(cipher, auxKey, seed) {
            let decrypted = '';
            for (let i = 0; i < cipher.length; i++) {
                const offset = await dynamicOffset(i, auxKey, seed);
                decrypted += shiftChar(cipher[i], -offset);
            }
            return decrypted;
        }

        function changeLanguage(lang) {
            currentLanguage = lang;
            
            // Update active language button
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update all text elements
            const t = translations[lang];
            document.getElementById('main-title').textContent = t.title;
            document.getElementById('main-description').textContent = t.description;
            document.getElementById('how-it-works').textContent = t.howItWorks;
            document.getElementById('how-it-works-desc').textContent = t.howItWorksDesc;
            document.getElementById('encrypt-text').textContent = t.encrypt;
            document.getElementById('decrypt-text').textContent = t.decrypt;
            document.getElementById('rotor-key-label').textContent = t.rotorKeyLabel;
            document.getElementById('seed-label').textContent = t.seedLabel;
            document.getElementById('generate-text').textContent = t.generateKey;
            document.getElementById('copy-text').textContent = t.copyResult;
            
            // Update placeholders
            document.getElementById('seed').placeholder = t.seedPlaceholder;
            
            // Update mode-specific text
            updateModeText();
            
            // Update result placeholder if needed
            const resultLabel = document.getElementById('resultLabel');
            if (resultLabel.classList.contains('placeholder')) {
                resultLabel.textContent = t.resultPlaceholder;
            }
        }

        function updateModeText() {
            const t = translations[currentLanguage];
            const textLabel = document.getElementById('textLabel');
            const processText = document.getElementById('process-text');
            const textInput = document.getElementById('textInput');
            
            if (currentMode === 'encrypt') {
                textLabel.textContent = t.encryptLabel;
                processText.textContent = t.encryptBtn;
                textInput.placeholder = t.encryptPlaceholder;
            } else {
                textLabel.textContent = t.decryptLabel;
                processText.textContent = t.decryptBtn;
                textInput.placeholder = t.decryptPlaceholder;
            }
        }

        function setMode(mode) {
            currentMode = mode;
            
            // Update button states
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.mode-btn.${mode}`).classList.add('active');
            
            // Update text based on current language
            updateModeText();
            
            // Clear results
            clearResults();
        }

        function validateInputs() {
            const text = document.getElementById('textInput').value;
            const rotorKey = document.getElementById('rotorKey').value;
            const seed = document.getElementById('seed').value;
            const errorDiv = document.getElementById('error');
            const t = translations[currentLanguage];
            
            errorDiv.textContent = '';
            
            if (!text.trim()) {
                errorDiv.textContent = t.errorEmptyText;
                return false;
            }
            
            if (rotorKey.length !== 32) {
                errorDiv.textContent = t.errorRotorLength;
                return false;
            }
            
            if (!/^[abcd]+$/.test(rotorKey)) {
                errorDiv.textContent = t.errorRotorChars;
                return false;
            }
            
            if (!seed.trim()) {
                errorDiv.textContent = t.errorEmptySeed;
                return false;
            }
            
            return true;
        }

        async function processText() {
            if (!validateInputs()) {
                return;
            }
            
            const text = document.getElementById('textInput').value;
            const rotorKey = document.getElementById('rotorKey').value;
            const seed = document.getElementById('seed').value;
            const processBtn = document.getElementById('processBtn');
            const t = translations[currentLanguage];
            
            // Show processing state
            processBtn.disabled = true;
            document.getElementById('process-text').textContent = t.processing;
            updateRotorVisualization(rotorKey);
            
            try {
                let result;
                if (currentMode === 'encrypt') {
                    result = await encrypt(text, rotorKey, seed);
                } else {
                    result = await decrypt(text, rotorKey, seed);
                }
                
                displayResult(result);
            } catch (error) {
                document.getElementById('error').textContent = t.errorProcessing;
                console.error(error);
            } finally {
                // Reset button
                processBtn.disabled = false;
                updateModeText();
                clearRotorVisualization();
            }
        }

        function displayResult(result) {
            const resultLabel = document.getElementById('resultLabel');
            const resultText = document.getElementById('resultText');
            const copyBtn = document.getElementById('copyBtn');
            const t = translations[currentLanguage];
            
            resultLabel.textContent = currentMode === 'encrypt' ? t.encryptedResult : t.decryptedResult;
            resultLabel.classList.remove('placeholder');
            
            resultText.textContent = result;
            resultText.style.display = 'block';
            copyBtn.style.display = 'inline-block';
        }

        function clearResults() {
            const resultLabel = document.getElementById('resultLabel');
            const resultText = document.getElementById('resultText');
            const copyBtn = document.getElementById('copyBtn');
            const t = translations[currentLanguage];
            
            resultLabel.textContent = t.resultPlaceholder;
            resultLabel.classList.add('placeholder');
            resultText.style.display = 'none';
            copyBtn.style.display = 'none';
        }

        function copyResult() {
            const resultText = document.getElementById('resultText').textContent;
            const t = translations[currentLanguage];
            
            navigator.clipboard.writeText(resultText).then(() => {
                const copyBtn = document.getElementById('copyBtn');
                const originalText = copyBtn.textContent;
                document.getElementById('copy-text').textContent = t.copied;
                setTimeout(() => {
                    document.getElementById('copy-text').textContent = t.copyResult;
                }, 2000);
            });
        }

        function updateRotorVisualization(rotorKey) {
            const rotorViz = document.getElementById('rotorViz');
            rotorViz.innerHTML = '';
            
            // Show first 8 rotor positions
            for (let i = 0; i < Math.min(8, rotorKey.length); i++) {
                const rotor = document.createElement('div');
                rotor.className = 'rotor';
                rotor.textContent = rotorKey[i].toUpperCase();
                rotorViz.appendChild(rotor);
            }
        }

        function clearRotorVisualization() {
            const rotorViz = document.getElementById('rotorViz');
            rotorViz.innerHTML = '';
        }

        function generateRotorKey() {
            let key = '';
            for (let i = 0; i < 32; i++) {
                key += ROTOR_CHARS[Math.floor(Math.random() * ROTOR_CHARS.length)];
            }
            document.getElementById('rotorKey').value = key;
        }

        // Enter key support
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Enter'
